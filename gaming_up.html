<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Arcade Nexus - Your Simple Gaming Hub</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom font import and utility */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@100..900&display=swap');
        
        body {
            font-family: 'Inter', sans-serif;
            background-color: #0d1117; /* Dark background for gaming feel */
            color: #e5e7eb; /* Light grey text */
        }
        
        .game-card {
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            cursor: pointer;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1);
        }

        .game-card:hover {
            transform: translateY(-5px);
            /* Subtle neon glow */
            box-shadow: 0 0 15px rgba(59, 130, 246, 0.7), 0 0 30px rgba(6, 182, 212, 0.5);
        }
        
        .cta-button {
            transition: background-color 0.2s, transform 0.1s;
        }

        .cta-button:hover {
            background-color: #1e40af; /* Darker blue */
        }

        /* Custom style for the game canvas to ensure it scales correctly */
        #gameCanvas {
            max-width: 100%;
            height: auto;
            display: block; 
            touch-action: manipulation; /* Improves touch responsiveness */
        }
        
        .answer-button {
            transition: background-color 0.1s, transform 0.1s;
        }
        .answer-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }
        .answer-button.correct {
            background-color: #10B981 !important; /* Green */
        }
        .answer-button.incorrect {
            background-color: #EF4444 !important; /* Red */
        }
        
        /* Spinner CSS */
        .spinner {
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 4px solid #3b82f6;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Mobile Controls Styling */
        .mobile-control-button {
            padding: 1.5rem;
            font-size: 1.5rem;
            font-weight: bold;
            border-radius: 9999px; /* Full rounded */
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.5);
            user-select: none;
            -webkit-user-select: none;
        }
    </style>
</head>
<body class="min-h-screen">

    <!-- Header / Navigation Bar (Hidden in Game View for Focus) -->
    <header class="bg-gray-800 shadow-xl sticky top-0 z-10" id="main-header">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4 flex justify-between items-center">
            <!-- Logo / Site Title -->
            <a href="#" onclick="exitGame(false)" class="text-3xl font-extrabold tracking-tight text-blue-400">
                <span class="text-cyan-300">Arcade</span>Nexus
            </a>
            <!-- Call to Action Button -->
            <button class="cta-button bg-blue-600 text-white font-semibold py-2 px-4 rounded-lg shadow-md hover:shadow-lg focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 focus:ring-offset-gray-800">
                Hub
            </button>
        </div>
    </header>

    <!-- Main Content Area -->
    <main class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-12">
        
        <!-- 1. HUB VIEW (Default View) -->
        <div id="hub-view">
            
            <!-- Hero Section -->
            <section class="text-center mb-16">
                <h1 class="text-5xl sm:text-6xl font-extrabold mb-4 text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-cyan-300">
                    Level Up Your Day
                </h1>
                <p class="text-xl text-gray-400 max-w-3xl mx-auto">
                    Discover a collection of simple, fast-paced arcade and puzzle games designed for maximum fun and quick breaks.
                </p>
            </section>

            <!-- Games Grid Section -->
            <section id="games" class="mb-16">
                <h2 class="text-4xl font-bold mb-8 text-center text-gray-200">Featured Games</h2>
                
                <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-8">
                    
                    <!-- Game Card 1: Retro Runner -->
                    <div class="game-card bg-gray-700 p-6 rounded-xl shadow-lg hover:shadow-blue-500/50" onclick="showGame('retroRunner');">
                        <div class="flex justify-center items-center h-40 bg-gray-800 rounded-lg mb-4">
                            <svg class="w-16 h-16 text-red-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path></svg>
                        </div>
                        <h3 class="text-2xl font-semibold mb-2 text-white">Retro Runner</h3>
                        <p class="text-gray-400 text-sm">A fast-paced endless runner. Tap the screen to jump!</p>
                        <span class="inline-block bg-blue-600 text-xs font-bold text-white px-3 py-1 mt-3 rounded-full">Arcade</span>
                    </div>

                    <!-- Game Card 2: Puzzle Blocks -->
                    <div class="game-card bg-gray-700 p-6 rounded-xl shadow-lg hover:shadow-cyan-500/50" onclick="showGame('puzzleBlocks');">
                        <div class="flex justify-center items-center h-40 bg-gray-800 rounded-lg mb-4">
                            <svg class="w-16 h-16 text-cyan-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M11 4a2 2 0 012 2v1h5.5l1.5 1.5A3.5 3.5 0 0118.5 14H11V4zM10 4v10a2 2 0 002 2h8a2 2 0 002-2V8a2 2 0 00-2-2h-3V4a2 2 0 00-2-2H12a2 2 0 00-2 2zM10 16v-2h2v2h-2z"></path></svg>
                        </div>
                        <h3 class="text-2xl font-semibold mb-2 text-white">Puzzle Blocks</h3>
                        <p class="text-gray-400 text-sm">Match and clear colorful blocks. Strategic fun for all ages.</p>
                        <span class="inline-block bg-green-600 text-xs font-bold text-white px-3 py-1 mt-3 rounded-full">Puzzle</span>
                    </div>

                    <!-- Game Card 3: Space Shooter -->
                    <div class="game-card bg-gray-700 p-6 rounded-xl shadow-lg hover:shadow-red-500/50" onclick="showGame('spaceShooter');">
                        <div class="flex justify-center items-center h-40 bg-gray-800 rounded-lg mb-4">
                            <svg class="w-16 h-16 text-yellow-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 19l9 2-9-18-9 18 9-2zm0 0v-8"></path></svg>
                        </div>
                        <h3 class="text-2xl font-semibold mb-2 text-white">Space Shooter</h3>
                        <p class="text-gray-400 text-sm">Defend the galaxy! Use the virtual gamepad on mobile.</p>
                        <span class="inline-block bg-red-600 text-xs font-bold text-white px-3 py-1 mt-3 rounded-full">Action</span>
                    </div>
                    
                    <!-- Game Card 4: Quiz Master -->
                    <div class="game-card bg-gray-700 p-6 rounded-xl shadow-lg hover:shadow-indigo-500/50" onclick="showGame('quizMaster');">
                        <div class="flex justify-center items-center h-40 bg-gray-800 rounded-lg mb-4">
                            <svg class="w-16 h-16 text-indigo-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M8.228 9.228a2 2 0 011.414.586L10 11.242l.354-.354a2 2 0 012.828 0l1.414 1.414a2 2 0 010 2.828l-5.657 5.657a2 2 0 01-2.828 0l-1.414-1.414a2 2 0 010-2.828l1.414-1.414a2 2 0 012.828 0z"></path></svg>
                        </div>
                        <h3 class="text-2xl font-semibold mb-2 text-white">Quiz Master</h3>
                        <p class="text-gray-400 text-sm">Trivia challenge! Compete in various categories against the clock.</p>
                        <span class="inline-block bg-indigo-600 text-xs font-bold text-white px-3 py-1 mt-3 rounded-full">Trivia</span>
                    </div>

                    <!-- Game Card 5: Fishing Frenzy -->
                    <div class="game-card bg-gray-700 p-6 rounded-xl shadow-lg hover:shadow-yellow-500/50" onclick="showGame('fishingFrenzy');">
                        <div class="flex justify-center items-center h-40 bg-gray-800 rounded-lg mb-4">
                            <svg class="w-16 h-16 text-yellow-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M17.657 18.657A8 8 0 017.343 3.343l-1.414 1.414a6 6 0 008.485 8.485l-1.414 1.414a4 4 0 01-5.657 0"></path><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 19a2 2 0 01-2 2h-4a2 2 0 01-2-2V9a2 2 0 012-2h4a2 2 0 012 2v10z"></path></svg>
                        </div>
                        <h3 class="text-2xl font-semibold mb-2 text-white">Fishing Frenzy</h3>
                        <p class="text-gray-400 text-sm">Catch the fish! Tap the screen at the right time.</p>
                        <span class="inline-block bg-yellow-600 text-xs font-bold text-white px-3 py-1 mt-3 rounded-full">Timing</span>
                    </div>

                    <!-- Game Card 6: Word Scramble -->
                    <div class="game-card bg-gray-700 p-6 rounded-xl shadow-lg hover:shadow-pink-500/50" onclick="showGame('wordScramble');">
                        <div class="flex justify-center items-center h-40 bg-gray-800 rounded-lg mb-4">
                            <svg class="w-16 h-16 text-pink-500" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 6.253v13m0-13C10.832 5.414 9.493 5 8 5c-4.418 0-8 2.825-8 6.375s3.582 6.375 8 6.375c1.493 0 2.832-.414 4-1.125m0-13C13.168 5.414 14.507 5 16 5c4.418 0 8 2.825 8 6.375s-3.582 6.375-8 6.375c-1.493 0-2.832-.414-4-1.125"></path></svg>
                        </div>
                        <h3 class="text-2xl font-semibold mb-2 text-white">Word Scramble</h3>
                        <p class="text-gray-400 text-sm">Unscramble the letters to form words. Great for brain exercise!</p>
                        <span class="inline-block bg-pink-600 text-xs font-bold text-white px-3 py-1 mt-3 rounded-full">Word</span>
                    </div>

                </div>
            </section>
            
            <!-- About Section -->
            <section id="about" class="bg-gray-800 p-10 rounded-xl shadow-2xl">
                <h2 class="text-3xl font-bold mb-4 text-center text-blue-400">About Arcade Nexus</h2>
                <p class="text-gray-400 text-center max-w-4xl mx-auto">
                    Arcade Nexus is dedicated to providing high-quality, free, and fun browser games. We believe gaming should be accessible, quick to jump into, and always entertaining. All games are designed to be fully responsive, working great on both your desktop and mobile devices. Start playing today, no downloads required!
                </p>
            </section>
            
        </div> <!-- End of #hub-view -->
        
        <!-- 2. GAME VIEW (The actual game container) -->
        <div id="game-view" class="hidden flex flex-col items-center">
            
            <!-- Game Header Controls -->
            <div class="flex justify-between w-full max-w-4xl mb-8">
                <button onclick="exitGame()" class="cta-button bg-red-600 text-white font-semibold py-2 px-6 rounded-lg hover:bg-red-700 transition duration-150 shadow-lg flex items-center">
                    <span class="inline-block mr-2 text-xl">←</span> Back to Arcade Hub
                </button>
                <button onclick="openAiModal()" id="askAiButton" class="cta-button bg-cyan-600 text-white font-semibold py-2 px-6 rounded-lg hover:bg-cyan-700 transition duration-150 shadow-lg flex items-center">
                    <svg class="w-5 h-5 mr-2" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9.663 17h4.673M12 3v1m6.364 1.636l-.707.707M3.636 5.636l.707.707M12 20.25V21M7.682 17.58l.707.707M16.318 17.58l-.707.707M2 13h18M5 11h14a1 1 0 011 1v1h-2v-1h-2v2h-2v-2h-2v2h-2v-2h-2v1H4v-1a1 1 0 011-1z"></path></svg>
                    Ask AI Master
                </button>
            </div>
            
            <h2 id="game-title" class="text-4xl font-extrabold mb-6 text-transparent bg-clip-text bg-gradient-to-r from-blue-400 to-cyan-300">Retro Runner</h2>
            
            <!-- Game Canvas Container -->
            <div class="w-full max-w-4xl">
                <!-- Game Canvas -->
                <canvas id="gameCanvas" class="w-full h-auto rounded-xl border-4 border-cyan-500 shadow-2xl bg-gray-900 cursor-pointer"></canvas>
            </div>
            
            <!-- Game Info (Score, Timer, Instructions) -->
            <div id="gameInfo" class="mt-8 text-center bg-gray-800 p-4 rounded-xl shadow-lg w-full max-w-md">
                <p class="text-xl text-gray-300 mb-2 flex justify-center space-x-6">
                    <span>Score: <span id="scoreDisplay" class="font-extrabold text-3xl text-cyan-400">0</span></span>
                    <span id="timerDisplay" class="font-extrabold text-2xl text-yellow-400 hidden">Time: 60s</span>
                    <span id="attemptsDisplay" class="font-extrabold text-2xl text-red-400 hidden">Tries: 10</span>
                </p>
                <p class="text-lg text-gray-400" id="instructionsDisplay">
                    
                </p>
            </div>

            <!-- Mobile Controls for Space Shooter (Hidden by Default) -->
            <div id="mobileControls" class="mt-8 w-full max-w-4xl flex justify-around p-4 hidden">
                <div class="flex space-x-6">
                    <button id="leftButton" class="mobile-control-button bg-gray-700 text-white hover:bg-gray-600 active:bg-blue-500 transition duration-100">
                        &#9664; <!-- Left Arrow -->
                    </button>
                    <button id="rightButton" class="mobile-control-button bg-gray-700 text-white hover:bg-gray-600 active:bg-blue-500 transition duration-100">
                        &#9654; <!-- Right Arrow -->
                    </button>
                </div>
                <button id="fireButton" class="mobile-control-button bg-red-600 text-white hover:bg-red-500 active:bg-red-700 transition duration-100">
                    &#9679; <!-- Circle/Fire -->
                </button>
            </div>
            
            <!-- Game Specific Controls Area (Hidden by default, used for Quiz/Scramble) -->
            <div id="gameControls" class="mt-4 w-full max-w-lg flex flex-col items-center">
                <!-- Content injected by JavaScript -->
            </div>
        </div> <!-- End of #game-view -->

    </main>

    <!-- Custom Alert/Message Box (Replaces alert()) -->
    <div id="custom-alert" class="hidden fixed inset-0 bg-black bg-opacity-70 flex justify-center items-center z-50">
        <div class="bg-gray-800 p-6 rounded-lg shadow-2xl max-w-sm w-full border-t-4 border-blue-500">
            <h4 class="text-xl font-bold text-white mb-3" id="alert-title">Game Action</h4>
            <p class="text-gray-300 mb-5" id="alert-message"></p>
            <button onclick="closeAlert()" class="w-full bg-blue-600 text-white py-2 rounded-lg font-semibold hover:bg-blue-700 transition duration-150">
                Got It
            </button>
        </div>
    </div>
    
    <!-- AI Game Master Modal -->
    <div id="ai-modal" class="hidden fixed inset-0 bg-black bg-opacity-80 flex justify-center items-center z-50 p-4">
        <div class="bg-gray-800 p-6 rounded-xl shadow-2xl max-w-xl w-full flex flex-col h-[80vh]">
            
            <div class="flex justify-between items-center pb-4 border-b border-gray-700">
                <h3 class="text-2xl font-bold text-cyan-400">AI Game Master</h3>
                <button onclick="closeAiModal()" class="text-gray-400 hover:text-white transition duration-150">
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>

            <!-- Chat History -->
            <div id="ai-chat-history" class="flex-grow overflow-y-auto space-y-4 py-4 text-sm">
                <!-- Initial AI Message -->
                <div class="flex justify-start">
                    <div class="bg-blue-900/50 text-white p-3 rounded-xl rounded-tl-none max-w-[80%] shadow-md">
                        <p>Hello there! I'm the AI Game Master for **<span id="ai-game-name"></span>**. Ask me for a hint, strategy tips, or a fun challenge!</p>
                    </div>
                </div>
            </div>

            <!-- Input Area -->
            <div class="pt-4 border-t border-gray-700 flex items-center">
                <input type="text" id="ai-prompt-input" placeholder="Ask for a hint or challenge..."
                    class="flex-grow p-3 rounded-l-lg bg-gray-900 text-white border border-gray-700 focus:outline-none focus:ring-2 focus:ring-cyan-500"
                    onkeydown="if(event.key === 'Enter') sendAiPrompt()">
                <button onclick="sendAiPrompt()" id="ai-send-button" class="cta-button bg-blue-600 text-white py-3 px-4 rounded-r-lg font-semibold hover:bg-blue-700 flex items-center justify-center disabled:opacity-50 disabled:cursor-not-allowed">
                    <span id="ai-send-text">Send</span>
                    <div id="ai-send-spinner" class="spinner ml-2 hidden"></div>
                </button>
            </div>
            
            <!-- Citation Area -->
            <div id="ai-citations" class="text-xs text-gray-500 pt-2 hidden">
                <p class="font-semibold mb-1">Sources:</p>
                <ul id="ai-citations-list" class="list-disc list-inside space-y-1"></ul>
            </div>
            
        </div>
    </div>

    <!-- JavaScript for Custom Alert and Game Logic -->
    <script>
        // --- API Key (Empty string required for auto-provisioning) ---
        const apiKey = "";
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;

        // --- Custom Alert Functions ---
        function alertCustom(message) {
            document.getElementById('alert-message').textContent = message;
            document.getElementById('custom-alert').classList.remove('hidden');
        }

        function closeAlert() {
            document.getElementById('custom-alert').classList.add('hidden');
        }
        
        // --- Global Game State and Variables ---
        let activeGameId = null; 
        const gameCanvas = document.getElementById('gameCanvas');
        const mobileControls = document.getElementById('mobileControls');
        const gameControls = document.getElementById('gameControls');
        const scoreDisplay = document.getElementById('scoreDisplay');
        const timerDisplay = document.getElementById('timerDisplay');
        const attemptsDisplay = document.getElementById('attemptsDisplay');
        const instructionsDisplay = document.getElementById('instructionsDisplay');
        const mainHeader = document.getElementById('main-header');

        // --- Game States ---
        const retroRunner = { canvas: null, ctx: null, player: { x: 0, y: 0, width: 0, height: 0, velocityY: 0, gravity: 0, jumpPower: 0, isJumping: false }, obstacles: [], score: 0, speed: 0, frame: 0, isRunning: false, animationFrameId: null, maxObstacles: 3, obstacleSpawnRate: 150 };
        const puzzleBlocks = { canvas: null, ctx: null, grid: [], cols: 12, rows: 10, blockSize: 0, score: 0, isRunning: false, animationFrameId: null, isGameOver: false, colors: ['#FF6347', '#4682B4', '#3CB371', '#FFD700', '#8A2BE2'], time: 60, timerIntervalId: null, };
        const spaceShooter = { 
            canvas: null, ctx: null, 
            player: { x: 0, y: 0, w: 40, h: 40, dx: 0, speed: 5 }, 
            enemies: [], bullets: [], score: 0, isRunning: false, frame: 0, 
            animationFrameId: null, keyMap: {}, lastShotTime: 0, shotCooldown: 300, 
            virtualControls: { left: false, right: false, shoot: false } // New for mobile
        };
        const quizMaster = { questions: [ { q: "What is the capital of France?", a: ["Berlin", "Madrid", "Paris", "Rome"], correct: "Paris" }, { q: "What is 2 + 2 * 2?", a: ["6", "8", "4", "12"], correct: "6" }, { q: "The biggest planet in our solar system is:", a: ["Mars", "Jupiter", "Earth", "Saturn"], correct: "Jupiter" }, { q: "Which programming language is this game built in?", a: ["Python", "Java", "C++", "JavaScript"], correct: "JavaScript" }, { q: "The primary purpose of HTML is to:", a: ["Style Content", "Structure Content", "Add Interactivity", "Store Data"], correct: "Structure Content" } ], currentQIndex: 0, score: 0, isRunning: false, totalQuestions: 5, };
        const fishingFrenzy = { canvas: null, ctx: null, gauge: { w: 20, h: 200 }, target: { y: 0, h: 50, color: '#10B981' }, marker: { y: 0, h: 5, direction: 1, speed: 3, color: '#F87171' }, score: 0, attempts: 10, remainingAttempts: 10, isRunning: false, animationFrameId: null, };
        const wordScramble = { wordList: ["PROGRAMMING", "JAVASCRIPT", "TAILWIND", "CANVAS", "ARCADE", "NEXUS", "RESPONSIVE", "CODING"], currentWord: "", scrambledWord: "", score: 0, isRunning: false, time: 60, timerIntervalId: null, currentWordIndex: 0, };

        // --- AI Game Master Functions (Kept as is for functionality) ---
        
        function openAiModal() {
            const gameTitle = document.getElementById('game-title').textContent;
            document.getElementById('ai-game-name').textContent = gameTitle;
            document.getElementById('ai-modal').classList.remove('hidden');
            document.getElementById('ai-chat-history').innerHTML = `
                <div class="flex justify-start">
                    <div class="bg-blue-900/50 text-white p-3 rounded-xl rounded-tl-none max-w-[80%] shadow-md">
                        <p>Hello there! I'm the AI Game Master for **${gameTitle}**. Ask me for a hint, strategy tips, or a fun challenge!</p>
                    </div>
                </div>
            `;
            document.getElementById('ai-citations').classList.add('hidden');
        }

        function closeAiModal() {
            document.getElementById('ai-modal').classList.add('hidden');
        }

        function appendMessage(sender, message, sources = []) {
            const history = document.getElementById('ai-chat-history');
            const newMessage = document.createElement('div');
            
            if (sender === 'user') {
                newMessage.className = 'flex justify-end';
                newMessage.innerHTML = `<div class="bg-gray-700 p-3 rounded-xl rounded-tr-none max-w-[80%] shadow-md">${message}</div>`;
            } else {
                newMessage.className = 'flex justify-start';
                let sourceHtml = '';
                if (sources.length > 0) {
                    sourceHtml = `
                        <div class="text-xs text-gray-400 mt-2 border-t border-gray-600 pt-1">
                            Source: <a href="${sources[0].uri}" target="_blank" class="hover:underline text-cyan-400">${sources[0].title || 'Link'}</a>
                        </div>
                    `;
                }
                newMessage.innerHTML = `<div class="bg-blue-900/50 text-white p-3 rounded-xl rounded-tl-none max-w-[80%] shadow-md">${message}${sourceHtml}</div>`;
            }
            history.appendChild(newMessage);
            history.scrollTop = history.scrollHeight; // Auto-scroll to latest message
        }

        function getCurrentGameContext() {
            const gameId = activeGameId;
            let context = `Game: ${document.getElementById('game-title').textContent}`;
            
            if (gameId === 'quizMaster' && quizMaster.isRunning && quizMaster.questions[quizMaster.currentQIndex]) {
                context += `, Current Question: "${quizMaster.questions[quizMaster.currentQIndex].q}"`;
            } else if (gameId === 'wordScramble' && wordScramble.isRunning) {
                context += `, Scrambled Word: "${wordScramble.scrambledWord}"`;
            } else if (gameId === 'retroRunner' || gameId === 'spaceShooter') {
                 context += `, Current Score: ${scoreDisplay.textContent}. The user needs tips on movement/timing.`;
            } else if (gameId === 'fishingFrenzy') {
                 context += `, Current Score: ${scoreDisplay.textContent}. The user needs tips on timing the catch.`;
            }
            return context;
        }
        
        async function callGeminiAPI(userQuery, systemInstruction, useGrounding = true) {
            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemInstruction }] },
                tools: useGrounding ? [{ "google_search": {} }] : undefined,
            };

            const sendButton = document.getElementById('ai-send-button');
            const sendText = document.getElementById('ai-send-text');
            const spinner = document.getElementById('ai-send-spinner');
            
            sendButton.disabled = true;
            sendText.classList.add('hidden');
            spinner.classList.remove('hidden');

            const maxRetries = 3;
            let response = null;
            let lastError = null;

            for (let attempt = 0; attempt < maxRetries; attempt++) {
                try {
                    const res = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });

                    if (!res.ok) {
                        const errorBody = await res.json();
                        throw new Error(`API returned status ${res.status}: ${errorBody.error.message}`);
                    }

                    response = await res.json();
                    break; 
                } catch (error) {
                    lastError = error;
                    console.error(`Attempt ${attempt + 1} failed:`, error);
                    if (attempt < maxRetries - 1) {
                        await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
                    }
                }
            }

            sendButton.disabled = false;
            sendText.classList.remove('hidden');
            spinner.classList.add('hidden');

            if (!response) {
                return { text: `Sorry, the AI Game Master is currently unavailable due to an error: ${lastError ? lastError.message : 'Unknown error.'}`, sources: [] };
            }

            const candidate = response.candidates?.[0];

            if (candidate && candidate.content?.parts?.[0]?.text) {
                const text = candidate.content.parts[0].text;
                let sources = [];
                const groundingMetadata = candidate.groundingMetadata;
                if (groundingMetadata && groundingMetadata.groundingAttributions) {
                    sources = groundingMetadata.groundingAttributions
                        .map(attribution => ({
                            uri: attribution.web?.uri,
                            title: attribution.web?.title,
                        }))
                        .filter(source => source.uri && source.title);
                }
                return { text, sources };
            } else {
                return { text: "I couldn't generate a helpful response right now. Please try again.", sources: [] };
            }
        }

        async function sendAiPrompt() {
            const inputField = document.getElementById('ai-prompt-input');
            const userPrompt = inputField.value.trim();

            if (!userPrompt) return;

            // 1. Append user message
            appendMessage('user', userPrompt);
            inputField.value = '';
            inputField.disabled = true; 

            // 2. Prepare API Request
            const gameContext = getCurrentGameContext();
            const fullPrompt = `${gameContext}. User's query: ${userPrompt}`;
            
            const systemPrompt = "You are the Arcade Nexus Game Master. Your goal is to provide fun, encouraging, and non-spoiler hints, challenges, or trivia related to the user's query about the game they are playing. Keep your answers concise, engaging, and in a friendly, enthusiastic tone.";
            
            // 3. Call API
            const result = await callGeminiAPI(fullPrompt, systemPrompt, true);

            // 4. Append AI response
            appendMessage('ai', result.text, result.sources);
            inputField.disabled = false;

            // Optional: Update citation area if needed
            const citationsDiv = document.getElementById('ai-citations');
            const citationsList = document.getElementById('ai-citations-list');
            
            citationsList.innerHTML = '';
            if (result.sources.length > 0) {
                result.sources.slice(0, 3).forEach(source => { 
                    const li = document.createElement('li');
                    li.innerHTML = `<a href="${source.uri}" target="_blank" class="hover:underline text-cyan-400">${source.title || source.uri}</a>`;
                    citationsList.appendChild(li);
                });
                citationsDiv.classList.remove('hidden');
            } else {
                citationsDiv.classList.add('hidden');
            }
        }


        // --- Canvas Resizing Utility ---
        function resizeGameCanvas() {
            if (!activeGameId) return;
            // Re-run the initialization function for the active game.
            // This ensures all element sizes (player, obstacles, blocks) are recalculated based on the new canvas size.
            if (activeGameId === 'retroRunner') initRetroRunner(true);
            else if (activeGameId === 'puzzleBlocks') initPuzzleBlocks(true);
            else if (activeGameId === 'spaceShooter') initSpaceShooter(true);
            else if (activeGameId === 'fishingFrenzy') initFishingFrenzy(true);
        }

        // --- Game Management Functions ---
        function showGame(gameId) {
            if (activeGameId) { exitGame(true); }
            
            document.getElementById('hub-view').classList.add('hidden');
            document.getElementById('game-view').classList.remove('hidden');
            mainHeader.classList.add('hidden'); 
            document.getElementById('askAiButton').classList.remove('hidden');

            activeGameId = gameId; 
            gameCanvas.onclick = null; 
            document.removeEventListener('keydown', handleKeyPressGlobal); 
            document.removeEventListener('keyup', handleKeyUpGlobal); 
            gameControls.innerHTML = ''; 
            gameCanvas.style.display = 'block'; 
            mobileControls.classList.add('hidden'); // Hide controls by default

            document.getElementById('game-title').textContent = gameId.replace(/([A-Z])/g, ' $1').trim();
            scoreDisplay.textContent = 0;
            timerDisplay.classList.add('hidden');
            attemptsDisplay.classList.add('hidden');

            if (gameId === 'retroRunner') {
                instructionsDisplay.innerHTML = 'Press <kbd class="px-2 py-1 bg-gray-700 rounded-md text-white shadow-inner">SPACE</kbd> or <kbd class="px-2 py-1 bg-gray-700 rounded-md text-white shadow-inner">Tap/Click Canvas</kbd> to Jump! Be careful not to jump twice!';
                gameCanvas.onclick = jumpRetroRunner; 
                document.addEventListener('keydown', handleKeyPressGlobal);
                initRetroRunner();

            } else if (gameId === 'puzzleBlocks') {
                instructionsDisplay.innerHTML = 'Click/Tap any block to clear it and all adjacent blocks of the same color.';
                timerDisplay.classList.remove('hidden');
                gameCanvas.onclick = handleBlockClick; 
                initPuzzleBlocks();

            } else if (gameId === 'spaceShooter') {
                instructionsDisplay.innerHTML = 'Use <kbd class="px-2 py-1 bg-gray-700 rounded-md text-white shadow-inner">←</kbd> / <kbd class="px-2 py-1 bg-gray-700 rounded-md text-white shadow-inner">→</kbd> or the **On-Screen Buttons** to Move. Press <kbd class="px-2 py-1 bg-gray-700 rounded-md text-white shadow-inner">SPACE</kbd> or the **Fire Button** to Shoot.';
                document.addEventListener('keydown', handleKeyPressGlobal);
                document.addEventListener('keyup', handleKeyUpGlobal);
                setupMobileControls(); // Setup mobile buttons
                mobileControls.classList.remove('hidden'); // Show mobile controls
                initSpaceShooter();

            } else if (gameId === 'quizMaster') {
                gameCanvas.style.display = 'none'; 
                instructionsDisplay.innerHTML = 'Answer all questions to complete the quiz.';
                initQuizMaster();

            } else if (gameId === 'fishingFrenzy') {
                instructionsDisplay.innerHTML = 'Click/Tap the canvas when the red marker is inside the green target zone!';
                attemptsDisplay.classList.remove('hidden');
                gameCanvas.onclick = attemptCatch;
                initFishingFrenzy();
                
            } else if (gameId === 'wordScramble') {
                gameCanvas.style.display = 'none'; 
                instructionsDisplay.innerHTML = 'Unscramble the word below! Press <kbd class="px-2 py-1 bg-gray-700 rounded-md text-white shadow-inner">ENTER</kbd> or the submit button to enter your guess.';
                timerDisplay.classList.remove('hidden');
                initWordScramble();
            }
        }

        function exitGame(silent = false) {
            // 1. Stop and clean up the currently active game
            if (retroRunner.animationFrameId) cancelAnimationFrame(retroRunner.animationFrameId);
            if (puzzleBlocks.animationFrameId) cancelAnimationFrame(puzzleBlocks.animationFrameId);
            if (spaceShooter.animationFrameId) cancelAnimationFrame(spaceShooter.animationFrameId);

            if (puzzleBlocks.timerIntervalId) clearInterval(puzzleBlocks.timerIntervalId);
            if (wordScramble.timerIntervalId) clearInterval(wordScramble.timerIntervalId);
            
            // Reset running flags
            retroRunner.isRunning = false;
            puzzleBlocks.isRunning = false;
            spaceShooter.isRunning = false;
            wordScramble.isRunning = false;

            // Clear event listeners and UI elements
            gameCanvas.onclick = null;
            gameControls.innerHTML = '';
            activeGameId = null; 
            document.removeEventListener('keydown', handleKeyPressGlobal);
            document.removeEventListener('keyup', handleKeyUpGlobal);
            window.removeEventListener('resize', resizeGameCanvas);
            mobileControls.classList.add('hidden'); // Ensure mobile controls are hidden

            // 2. Hide AI Modal and show site navigation
            closeAiModal();
            if (!silent) {
                document.getElementById('game-view').classList.add('hidden');
                document.getElementById('hub-view').classList.remove('hidden');
                mainHeader.classList.remove('hidden');
            }
        }
        
        // --- Global Key Handlers (Delegates based on active game) ---
        function handleKeyPressGlobal(e) {
            if (activeGameId === 'retroRunner') {
                if (e.code === 'Space') { e.preventDefault(); jumpRetroRunner(); }
            } else if (activeGameId === 'spaceShooter') {
                spaceShooter.keyMap[e.code] = true;
                if (e.code === 'Space') { e.preventDefault(); shootSpaceShooter(); }
            } else if (activeGameId === 'wordScramble') {
                if (e.code === 'Enter') { submitScrambleGuess(); }
            }
        }
        function handleKeyUpGlobal(e) {
            if (activeGameId === 'spaceShooter') {
                spaceShooter.keyMap[e.code] = false;
            }
        }

        // --- Space Shooter Mobile Controls Setup ---
        function setupMobileControls() {
            const game = spaceShooter;

            const handleControl = (control, value) => {
                return (e) => {
                    e.preventDefault();
                    game.virtualControls[control] = value;
                    if (control === 'shoot' && value) {
                        shootSpaceShooter();
                    }
                };
            };
            
            const leftBtn = document.getElementById('leftButton');
            const rightBtn = document.getElementById('rightButton');
            const fireBtn = document.getElementById('fireButton');
            
            // Use touch events for mobile
            leftBtn.ontouchstart = handleControl('left', true);
            leftBtn.ontouchend = handleControl('left', false);
            rightBtn.ontouchstart = handleControl('right', true);
            rightBtn.ontouchend = handleControl('right', false);
            
            // Mouse events for non-touch (or combined touch/mouse)
            leftBtn.onmousedown = handleControl('left', true);
            leftBtn.onmouseup = handleControl('left', false);
            rightBtn.onmousedown = handleControl('right', true);
            rightBtn.onmouseup = handleControl('right', false);

            // Fire button handling (uses click/tap for single shot)
            fireBtn.ontouchstart = handleControl('shoot', true); // Shoot on touch start
            fireBtn.ontouchend = handleControl('shoot', false);  // Stop shoot on touch end (for continuous if needed, but tap is better for single shot)
            fireBtn.onmousedown = handleControl('shoot', true);
            fireBtn.onmouseup = handleControl('shoot', false);
        }
        
        // =======================================================
        // --- Retro Runner Logic ---
        // =======================================================
        const ORIGINAL_WIDTH = 800;
        const ORIGINAL_HEIGHT = 300;
        
        function initRetroRunner(isResize = false) {
            const runner = retroRunner;
            runner.canvas = gameCanvas;
            runner.ctx = runner.canvas.getContext('2d');
            
            // Set canvas size based on parent container width, maintaining aspect ratio
            runner.canvas.width = runner.canvas.offsetWidth;
            runner.canvas.height = runner.canvas.offsetWidth * (ORIGINAL_HEIGHT / ORIGINAL_WIDTH);
            
            const scale = runner.canvas.width / ORIGINAL_WIDTH; 
            
            // Scale all dimensions
            runner.player.width = 30 * scale; 
            runner.player.height = 50 * scale;
            runner.player.x = 50 * scale; 
            runner.player.gravity = 0.8 * scale;
            runner.player.jumpPower = -15 * scale;
            runner.speed = 5 * scale; 
            const groundThickness = 10 * scale; 
            const groundLine = runner.canvas.height - groundThickness;
            
            runner.player.y = groundLine - runner.player.height; 
            runner.player.isJumping = false; 
            runner.player.velocityY = 0;
            runner.obstacleSpawnRate = 150;

            if (!isResize) {
                runner.obstacles = []; 
                runner.score = 0; 
                runner.frame = 0;
                runner.isRunning = true;
                scoreDisplay.textContent = runner.score;
                gameLoopRetroRunner();
            } else if (runner.isRunning) {
                // If resizing during an active game, redraw immediately.
                drawGameRetroRunner();
            }

            if (runner.isRunning) window.addEventListener('resize', resizeGameCanvas);
        }
        
        function jumpRetroRunner() {
            if (retroRunner.isRunning && !retroRunner.player.isJumping) {
                retroRunner.player.isJumping = true;
                retroRunner.player.velocityY = retroRunner.player.jumpPower;
            }
        }
        
        function updateGameRetroRunner() {
            const runner = retroRunner; if (!runner.isRunning) return;
            runner.frame++; 
            runner.score = Math.floor(runner.frame / 10);
            scoreDisplay.textContent = runner.score;
            
            const scale = runner.canvas.width / ORIGINAL_WIDTH; 
            const initialSpeed = 5 * scale;
            runner.speed = initialSpeed + (runner.score * 0.005 * scale); 
            
            // Gravity and Vertical movement
            runner.player.velocityY += runner.player.gravity;
            runner.player.y += runner.player.velocityY;
            
            const groundThickness = 10 * scale;
            const groundLine = runner.canvas.height - groundThickness;
            const groundY = groundLine - runner.player.height;
            
            // Check if player lands on the ground
            if (runner.player.y >= groundY) {
                runner.player.y = groundY; 
                runner.player.isJumping = false; 
                runner.player.velocityY = 0;
            }
            
            // Obstacle Spawning
            if (runner.frame % runner.obstacleSpawnRate === 0 && runner.obstacles.length < runner.maxObstacles) {
                const obstacleWidth = scale * (20 + Math.random() * 20);
                const obstacleHeight = scale * (20 + Math.random() * 30);
                runner.obstacles.push({ 
                    x: runner.canvas.width, 
                    y: groundLine - obstacleHeight, 
                    width: obstacleWidth, 
                    height: obstacleHeight 
                });
                runner.obstacleSpawnRate = Math.max(80, 150 - Math.floor(runner.score / 15));
            }
            
            let collision = false;
            runner.obstacles = runner.obstacles.filter(obstacle => {
                obstacle.x -= runner.speed;
                
                // Collision Detection 
                if (runner.player.x < obstacle.x + obstacle.width && 
                    runner.player.x + runner.player.width > obstacle.x &&
                    runner.player.y < obstacle.y + obstacle.height && 
                    runner.player.y + runner.player.height > obstacle.y) { 
                    collision = true; 
                }
                
                return obstacle.x + obstacle.width > 0; 
            });
            
            if (collision) { gameOverRetroRunner(); }
        }
        
        function drawGameRetroRunner() {
            const runner = retroRunner; 
            runner.ctx.clearRect(0, 0, runner.canvas.width, runner.canvas.height);
            
            const scale = runner.canvas.width / ORIGINAL_WIDTH;
            const groundThickness = 10 * scale;
            const groundLine = runner.canvas.height - groundThickness;
            
            // Draw Ground
            runner.ctx.fillStyle = '#10B981'; 
            runner.ctx.fillRect(0, groundLine, runner.canvas.width, groundThickness);
            
            // Draw Player
            runner.ctx.fillStyle = '#F87171'; 
            runner.ctx.fillRect(runner.player.x, runner.player.y, runner.player.width, runner.player.height);
            
            // Draw Obstacles
            runner.ctx.fillStyle = '#FBBF24'; 
            runner.obstacles.forEach(obstacle => { 
                runner.ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height); 
            });
        }
        
        function gameLoopRetroRunner() {
            if (!retroRunner.isRunning) return;
            updateGameRetroRunner(); 
            drawGameRetroRunner();
            retroRunner.animationFrameId = requestAnimationFrame(gameLoopRetroRunner);
        }
        
        function gameOverRetroRunner() {
            retroRunner.isRunning = false; 
            cancelAnimationFrame(retroRunner.animationFrameId);
            window.removeEventListener('resize', resizeGameCanvas);
            const ctx = retroRunner.ctx; 
            ctx.textAlign = 'center';
            const gameOverFontSize = Math.min(48, retroRunner.canvas.height * 0.15); 
            ctx.font = `bold ${gameOverFontSize}px Inter`; 
            ctx.fillStyle = 'white';
            ctx.fillText('GAME OVER', retroRunner.canvas.width / 2, retroRunner.canvas.height / 2);
            const scoreFontSize = Math.min(24, retroRunner.canvas.height * 0.08);
            ctx.font = `${scoreFontSize}px Inter`;
            ctx.fillText(`Final Score: ${retroRunner.score}`, retroRunner.canvas.width / 2, retroRunner.canvas.height / 2 + scoreFontSize + 10);
            alertCustom(`Game Over! Your final score is ${retroRunner.score}.`);
        }
        
        // =======================================================
        // --- Puzzle Blocks Logic ---
        // =======================================================
        function initPuzzleBlocks(isResize = false) {
            const game = puzzleBlocks;
            game.canvas = gameCanvas;
            game.ctx = game.canvas.getContext('2d');
            
            // Set size based on width
            game.canvas.width = game.canvas.offsetWidth;
            game.blockSize = Math.floor(game.canvas.width / game.cols);
            game.canvas.height = game.blockSize * game.rows; 
            
            if (!isResize) {
                game.grid = Array(game.rows).fill(0).map(() => Array(game.cols).fill(0).map(() => Math.floor(Math.random() * game.colors.length) + 1));
                game.score = 0; game.time = 60; game.isRunning = true; game.isGameOver = false;
                scoreDisplay.textContent = game.score;
                timerDisplay.textContent = `Time: ${game.time}s`;
                game.timerIntervalId = setInterval(handleTimerPuzzleBlocks, 1000);
                gameLoopPuzzleBlocks();
            } else if (game.isRunning) {
                drawGamePuzzleBlocks(); // Redraw on resize
            }

            if (game.isRunning) window.addEventListener('resize', resizeGameCanvas);
        }

        function handleTimerPuzzleBlocks() {
            const game = puzzleBlocks; if (!game.isRunning) return;
            game.time--; timerDisplay.textContent = `Time: ${game.time}s`;
            if (game.time <= 0) { gameOverPuzzleBlocks(); }
        }
        function getBlockColor(value) {
            return value > 0 ? puzzleBlocks.colors[value - 1] : '#1F2937';
        }
        function drawGamePuzzleBlocks() {
            const game = puzzleBlocks; if (!game.isRunning) return;
            game.ctx.clearRect(0, 0, game.canvas.width, game.canvas.height);
            for (let r = 0; r < game.rows; r++) {
                for (let c = 0; c < game.cols; c++) {
                    const blockValue = game.grid[r][c];
                    const x = c * game.blockSize;
                    const y = r * game.blockSize;
                    game.ctx.fillStyle = getBlockColor(blockValue);
                    game.ctx.fillRect(x, y, game.blockSize - 2, game.blockSize - 2); 
                }
            }
        }
        function updateGamePuzzleBlocks() {
            const game = puzzleBlocks; if (!game.isRunning) return;
            // Apply Gravity
            for (let c = 0; c < game.cols; c++) {
                let emptySpaces = 0;
                for (let r = game.rows - 1; r >= 0; r--) {
                    if (game.grid[r][c] === 0) { emptySpaces++; } 
                    else if (emptySpaces > 0) {
                        game.grid[r + emptySpaces][c] = game.grid[r][c];
                        game.grid[r][c] = 0;
                    }
                }
            }
            // Replenish
            for (let c = 0; c < game.cols; c++) {
                for (let r = 0; r < game.rows; r++) {
                    if (game.grid[r][c] === 0) {
                        game.grid[r][c] = Math.floor(Math.random() * game.colors.length) + 1;
                    }
                }
            }
        }
        function handleBlockClick(e) {
            const game = puzzleBlocks; if (!game.isRunning || game.isGameOver) return;
            const rect = game.canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;
            const c = Math.floor(clickX / game.blockSize);
            const r = Math.floor(clickY / game.blockSize);
            if (r >= 0 && r < game.rows && c >= 0 && c < game.cols) {
                const startValue = game.grid[r][c];
                if (startValue > 0) {
                    const clearedCount = clearAdjacentBlocks(r, c, startValue);
                    if (clearedCount > 1) { 
                        game.score += clearedCount * clearedCount * 5;
                        scoreDisplay.textContent = game.score;
                    } else {
                        game.grid[r][c] = startValue; 
                    }
                }
            }
        }
        function clearAdjacentBlocks(r, c, targetValue) {
            const game = puzzleBlocks;
            if (r < 0 || r >= game.rows || c < 0 || c >= game.cols || game.grid[r][c] !== targetValue || game.grid[r][c] === 0) {
                return 0;
            }
            game.grid[r][c] = 0; 
            let count = 1;
            count += clearAdjacentBlocks(r + 1, c, targetValue); count += clearAdjacentBlocks(r - 1, c, targetValue);
            count += clearAdjacentBlocks(r, c + 1, targetValue); count += clearAdjacentBlocks(r, c - 1, targetValue);
            return count;
        }
        function gameLoopPuzzleBlocks() {
            const game = puzzleBlocks; if (!game.isRunning) return;
            updateGamePuzzleBlocks(); drawGamePuzzleBlocks();
            game.animationFrameId = requestAnimationFrame(gameLoopPuzzleBlocks);
        }
        function gameOverPuzzleBlocks() {
            const game = puzzleBlocks; game.isRunning = false; game.isGameOver = true;
            clearInterval(game.timerIntervalId); cancelAnimationFrame(game.animationFrameId);
            window.removeEventListener('resize', resizeGameCanvas);
            const ctx = game.ctx; ctx.textAlign = 'center';
            ctx.fillStyle = 'rgba(0, 0, 0, 0.7)'; ctx.fillRect(0, 0, game.canvas.width, game.canvas.height);
            const gameOverFontSize = Math.min(48, game.canvas.height * 0.15); 
            ctx.font = `bold ${gameOverFontSize}px Inter`; ctx.fillStyle = 'white';
            ctx.fillText('TIME UP!', game.canvas.width / 2, game.canvas.height / 2 - 10);
            const scoreFontSize = Math.min(24, game.canvas.height * 0.08);
            ctx.font = `${scoreFontSize}px Inter`;
            ctx.fillText(`Final Score: ${game.score}`, game.canvas.width / 2, game.canvas.height / 2 + scoreFontSize + 10);
            alertCustom(`Time Up! Your final score in Puzzle Blocks is ${game.score}.`);
        }
        
        // =======================================================
        // --- Space Shooter Logic ---
        // =======================================================
        function initSpaceShooter(isResize = false) {
            const game = spaceShooter;
            game.canvas = gameCanvas;
            game.ctx = game.canvas.getContext('2d');
            
            // Set canvas size
            const aspectRatio = 4 / 3;
            game.canvas.width = game.canvas.offsetWidth;
            game.canvas.height = game.canvas.width / aspectRatio;
            
            // Recalculate scaled properties
            game.player.w = game.canvas.width * 0.05; 
            game.player.h = game.player.w;
            game.player.speed = game.canvas.width * 0.008;
            game.player.x = game.canvas.width / 2;
            game.player.y = game.canvas.height - game.player.h; 

            if (!isResize) {
                game.enemies = []; game.bullets = []; game.score = 0; game.frame = 0;
                game.isRunning = true; game.keyMap = {};
                scoreDisplay.textContent = 0;
                gameLoopSpaceShooter();
            } else if (game.isRunning) {
                drawGameSpaceShooter();
            }
            
            if (game.isRunning) window.addEventListener('resize', resizeGameCanvas);
        }

        function shootSpaceShooter() {
            const game = spaceShooter;
            const currentTime = Date.now();
            if (currentTime - game.lastShotTime > game.shotCooldown) {
                game.bullets.push({ 
                    x: game.player.x, 
                    y: game.player.y, 
                    r: game.canvas.width * 0.005, // Scaled bullet size
                    speed: game.canvas.height * 0.02
                });
                game.lastShotTime = currentTime;
            }
        }

        function updateGameSpaceShooter() {
            const game = spaceShooter;
            if (!game.isRunning) return;

            game.frame++;

            // 1. Handle Player Movement (Keyboard OR Virtual)
            game.player.dx = 0;
            if (game.keyMap['ArrowLeft'] || game.keyMap['KeyA'] || game.virtualControls.left) { game.player.dx = -game.player.speed; }
            if (game.keyMap['ArrowRight'] || game.keyMap['KeyD'] || game.virtualControls.right) { game.player.dx = game.player.speed; }
            game.player.x += game.player.dx;
            
            // Boundary check
            if (game.player.x < game.player.w / 2) game.player.x = game.player.w / 2;
            if (game.player.x > game.canvas.width - game.player.w / 2) game.player.x = game.canvas.width - game.player.w / 2;

            // 2. Update Bullets
            game.bullets = game.bullets.filter(b => {
                b.y -= b.speed;
                return b.y > 0;
            });

            // 3. Update Enemies
            const enemySpeed = game.canvas.height * 0.005 + game.score * 0.0001;
            game.enemies = game.enemies.filter(e => {
                e.y += enemySpeed;
                // Collision with Player
                if (e.y + e.h / 2 > game.player.y - game.player.h / 2 && e.y - e.h / 2 < game.player.y + game.player.h / 2 &&
                    e.x + e.w / 2 > game.player.x - game.player.w / 2 && e.x - e.w / 2 < game.player.x + game.player.w / 2) {
                    gameOverSpaceShooter();
                    return false;
                }
                return e.y < game.canvas.height;
            });
            
            // 4. Spawn Enemies
            if (game.frame % Math.max(30, 100 - game.score * 2) === 0) {
                const enemySize = game.canvas.width * 0.03;
                game.enemies.push({
                    x: Math.random() * (game.canvas.width - enemySize) + enemySize / 2,
                    y: -enemySize,
                    w: enemySize,
                    h: enemySize,
                    health: 1
                });
            }

            // 5. Collision Detection (Bullets vs. Enemies)
            for (let i = game.bullets.length - 1; i >= 0; i--) {
                const bullet = game.bullets[i];
                let hit = false;
                for (let j = game.enemies.length - 1; j >= 0; j--) {
                    const enemy = game.enemies[j];
                    if (bullet.x > enemy.x - enemy.w / 2 && bullet.x < enemy.x + enemy.w / 2 &&
                        bullet.y > enemy.y - enemy.h / 2 && bullet.y < enemy.y + enemy.h / 2) {
                        
                        game.score += 10;
                        scoreDisplay.textContent = game.score;
                        game.enemies.splice(j, 1); 
                        hit = true;
                        break;
                    }
                }
                if (hit) {
                    game.bullets.splice(i, 1); 
                }
            }
        }

        function drawGameSpaceShooter() {
            const game = spaceShooter;
            game.ctx.fillStyle = '#0f172a'; // Deep space background
            game.ctx.fillRect(0, 0, game.canvas.width, game.canvas.height);

            // Draw Player (Blue Triangle)
            game.ctx.fillStyle = '#60a5fa'; 
            game.ctx.beginPath();
            game.ctx.moveTo(game.player.x, game.player.y - game.player.h / 2); // Top tip
            game.ctx.lineTo(game.player.x - game.player.w / 2, game.player.y + game.player.h / 2); // Bottom left
            game.ctx.lineTo(game.player.x + game.player.w / 2, game.player.y + game.player.h / 2); // Bottom right
            game.ctx.closePath();
            game.ctx.fill();

            // Draw Bullets (Yellow Circles)
            game.ctx.fillStyle = '#fde047'; 
            game.bullets.forEach(b => {
                game.ctx.beginPath();
                game.ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
                game.ctx.fill();
            });

            // Draw Enemies (Red Squares)
            game.ctx.fillStyle = '#ef4444'; 
            game.enemies.forEach(e => {
                game.ctx.fillRect(e.x - e.w / 2, e.y - e.h / 2, e.w, e.h);
            });
        }

        function gameLoopSpaceShooter() {
            if (!spaceShooter.isRunning) return;
            updateGameSpaceShooter();
            drawGameSpaceShooter();
            spaceShooter.animationFrameId = requestAnimationFrame(gameLoopSpaceShooter);
        }

        function gameOverSpaceShooter() {
            spaceShooter.isRunning = false;
            cancelAnimationFrame(spaceShooter.animationFrameId);
            window.removeEventListener('resize', resizeGameCanvas);
            const ctx = spaceShooter.ctx; ctx.textAlign = 'center';
            const gameOverFontSize = Math.min(48, spaceShooter.canvas.height * 0.15); 
            ctx.font = `bold ${gameOverFontSize}px Inter`; ctx.fillStyle = 'white';
            ctx.fillText('DEFEAT!', spaceShooter.canvas.width / 2, spaceShooter.canvas.height / 2);
            const scoreFontSize = Math.min(24, spaceShooter.canvas.height * 0.08);
            ctx.font = `${scoreFontSize}px Inter`;
            ctx.fillText(`Final Score: ${spaceShooter.score}`, spaceShooter.canvas.width / 2, spaceShooter.canvas.height / 2 + scoreFontSize + 10);
            alertCustom(`Game Over! You were hit! Final Score: ${spaceShooter.score}.`);
        }
        
        // =======================================================
        // --- Quiz Master Logic (No Canvas Resizing needed) ---
        // =======================================================
        function initQuizMaster() {
            const game = quizMaster;
            game.score = 0;
            game.currentQIndex = 0;
            game.isRunning = true;
            scoreDisplay.textContent = 0;
            displayQuestion();
        }

        function displayQuestion() {
            const game = quizMaster;
            if (game.currentQIndex >= game.questions.length) {
                return gameOverQuizMaster();
            }

            const currentQ = game.questions[game.currentQIndex];
            gameControls.innerHTML = `
                <div class="bg-gray-700 p-6 rounded-xl w-full text-left shadow-2xl">
                    <p class="text-xl font-semibold mb-4 text-white">Question ${game.currentQIndex + 1} of ${game.questions.length}:</p>
                    <p class="text-2xl font-bold mb-6 text-blue-300">${currentQ.q}</p>
                    <div id="answer-buttons" class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                        ${currentQ.a.map((answer, index) => `
                            <button 
                                class="answer-button bg-gray-600 text-white py-3 px-4 rounded-lg font-medium text-lg text-left hover:bg-gray-500"
                                onclick="checkAnswer('${answer}')"
                                data-answer="${answer}">
                                ${String.fromCharCode(65 + index)}. ${answer}
                            </button>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        function checkAnswer(selectedAnswer) {
            const game = quizMaster;
            const currentQ = game.questions[game.currentQIndex];
            const answerButtons = document.querySelectorAll('#answer-buttons button');
            
            game.isRunning = false; 

            answerButtons.forEach(button => {
                button.disabled = true;
                if (button.dataset.answer === currentQ.correct) {
                    button.classList.add('correct');
                } else if (button.dataset.answer === selectedAnswer) {
                    button.classList.add('incorrect');
                }
            });

            if (selectedAnswer === currentQ.correct) {
                game.score += 10;
                scoreDisplay.textContent = game.score;
            }

            setTimeout(() => {
                game.currentQIndex++;
                game.isRunning = true; 
                displayQuestion();
            }, 1500);
        }

        function gameOverQuizMaster() {
            quizMaster.isRunning = false;
            gameControls.innerHTML = `
                <div class="bg-gray-700 p-8 rounded-xl w-full text-center shadow-2xl">
                    <h3 class="text-3xl font-bold text-cyan-400 mb-4">Quiz Complete!</h3>
                    <p class="text-xl text-white mb-6">You got ${quizMaster.questions.length} questions!</p>
                    <p class="text-4xl font-extrabold text-yellow-400 mb-6">Final Score: ${quizMaster.score}</p>
                    <button onclick="showGame('quizMaster')" class="cta-button bg-blue-600 text-white py-3 px-8 rounded-lg font-semibold hover:bg-blue-700">
                        Play Again
                    </button>
                </div>
            `;
            alertCustom(`Quiz Finished! Your final score is ${quizMaster.score}.`);
        }
        
        // =======================================================
        // --- Fishing Frenzy Logic ---
        // =======================================================
        function initFishingFrenzy(isResize = false) {
            const game = fishingFrenzy;
            game.canvas = gameCanvas;
            game.ctx = game.canvas.getContext('2d');

            const canvasSize = 400;
            // Set canvas size square based on min of container width and max size
            const size = Math.min(game.canvas.offsetWidth, canvasSize);
            game.canvas.width = size;
            game.canvas.height = size;

            // Positioning for responsiveness
            game.gauge.w = game.canvas.width * 0.05;
            game.gauge.h = game.canvas.height * 0.8;
            game.gauge.x = game.canvas.width / 2 - game.gauge.w / 2;
            game.marker.speed = game.canvas.height * 0.008;

            if (!isResize) {
                game.score = 0; game.remainingAttempts = game.attempts;
                game.isRunning = true;
                scoreDisplay.textContent = game.score;
                attemptsDisplay.textContent = `Tries: ${game.remainingAttempts}`;
                resetMarkerAndTarget();
                gameLoopFishingFrenzy();
            } else if (game.isRunning) {
                drawGameFishingFrenzy();
            }

            if (game.isRunning) window.addEventListener('resize', resizeGameCanvas);
        }

        function resetMarkerAndTarget() {
            const game = fishingFrenzy;
            const minHeight = game.canvas.height * 0.1;
            const maxHeight = game.canvas.height * 0.9;
            const gaugeHeight = maxHeight - minHeight;
            
            game.marker.y = minHeight;
            game.marker.direction = 1;
            game.target.h = gaugeHeight * (0.15 + Math.random() * 0.2); // Target 15% to 35% of gauge height
            
            const maxTargetY = maxHeight - game.target.h;
            game.target.y = minHeight + Math.random() * (maxTargetY - minHeight);
        }

        function attemptCatch() {
            const game = fishingFrenzy;
            if (!game.isRunning || game.remainingAttempts <= 0) return;

            game.remainingAttempts--;
            attemptsDisplay.textContent = `Tries: ${game.remainingAttempts}`;

            const markerCenter = game.marker.y + game.marker.h / 2;
            const isHit = markerCenter >= game.target.y && markerCenter <= game.target.y + game.target.h;

            if (isHit) {
                game.score += 10;
                scoreDisplay.textContent = game.score;
                alertCustom("Great Catch! (+10 points)");
            } else {
                alertCustom("Missed the fish! Keep practicing your timing.");
            }
            
            if (game.remainingAttempts <= 0) {
                return gameOverFishingFrenzy();
            }

            // Prepare for next attempt
            resetMarkerAndTarget();
        }

        function updateGameFishingFrenzy() {
            const game = fishingFrenzy;
            if (!game.isRunning) return;
            
            const minHeight = game.canvas.height * 0.1;
            const maxHeight = game.canvas.height * 0.9;

            // Move marker
            game.marker.y += game.marker.speed * game.marker.direction;

            // Reverse direction if hitting boundaries
            if (game.marker.y < minHeight) {
                game.marker.y = minHeight;
                game.marker.direction = 1;
            } else if (game.marker.y > maxHeight - game.marker.h) {
                game.marker.y = maxHeight - game.marker.h;
                game.marker.direction = -1;
            }
        }

        function drawGameFishingFrenzy() {
            const game = fishingFrenzy;
            game.ctx.fillStyle = '#0f172a';
            game.ctx.fillRect(0, 0, game.canvas.width, game.canvas.height);

            const minHeight = game.canvas.height * 0.1;
            const maxHeight = game.canvas.height * 0.9;
            const trackW = game.gauge.w * 0.5;
            const trackX = game.canvas.width / 2 - trackW / 2;
            const trackHeight = maxHeight - minHeight;

            // Draw the Gauge Track (Dark Blue)
            game.ctx.fillStyle = '#1e40af';
            game.ctx.fillRect(trackX, minHeight, trackW, trackHeight);

            // Draw Target Zone (Green)
            game.ctx.fillStyle = game.target.color;
            game.ctx.fillRect(trackX, game.target.y, trackW, game.target.h);

            // Draw Marker (Red)
            game.ctx.fillStyle = game.marker.color;
            game.ctx.fillRect(trackX - trackW * 0.5, game.marker.y, trackW * 2, game.marker.h); 
        }

        function gameLoopFishingFrenzy() {
            if (!fishingFrenzy.isRunning) return;
            updateGameFishingFrenzy();
            drawGameFishingFrenzy();
            fishingFrenzy.animationFrameId = requestAnimationFrame(gameLoopFishingFrenzy);
        }

        function gameOverFishingFrenzy() {
            fishingFrenzy.isRunning = false;
            cancelAnimationFrame(fishingFrenzy.animationFrameId);
            window.removeEventListener('resize', resizeGameCanvas);
            alertCustom(`Fishing Trip Over! You ran out of tries. Final Score: ${fishingFrenzy.score}.`);
        }
        
        // =======================================================
        // --- Word Scramble Logic (No Canvas Resizing needed) ---
        // =======================================================
        function shuffleWord(word) {
            let parts = word.split('');
            for (let i = parts.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [parts[i], parts[j]] = [parts[j], parts[i]];
            }
            return parts.join('');
        }

        function initWordScramble() {
            const game = wordScramble;
            game.score = 0;
            game.currentWordIndex = 0;
            game.time = 60;
            game.isRunning = true;
            scoreDisplay.textContent = 0;
            timerDisplay.textContent = `Time: ${game.time}s`;

            // Setup input field once
            gameControls.innerHTML = `
                <div class="bg-gray-700 p-6 rounded-xl w-full text-center shadow-2xl">
                    <p id="scrambledWordDisplay" class="text-4xl font-extrabold text-yellow-400 mb-6 tracking-widest"></p>
                    <input type="text" id="scrambleInput" placeholder="Type your guess here" 
                        class="w-full p-3 mb-4 rounded-lg bg-gray-900 text-white border border-cyan-500 focus:outline-none focus:ring-2 focus:ring-cyan-400 text-center text-xl uppercase"/>
                    <button onclick="submitScrambleGuess()" class="cta-button bg-blue-600 text-white py-3 px-8 rounded-lg font-semibold hover:bg-blue-700 w-full">
                        Submit Guess
                    </button>
                </div>
            `;
            document.addEventListener('keydown', handleKeyPressGlobal);

            // Start timer
            game.timerIntervalId = setInterval(handleTimerWordScramble, 1000);

            loadNextWord();
        }

        function handleTimerWordScramble() {
            const game = wordScramble;
            if (!game.isRunning) return;

            game.time--;
            timerDisplay.textContent = `Time: ${game.time}s`;

            if (game.time <= 0) {
                gameOverWordScramble();
            }
        }

        function loadNextWord() {
            const game = wordScramble;
            if (game.currentWordIndex >= game.wordList.length) {
                return gameOverWordScramble();
            }

            game.currentWord = game.wordList[game.currentWordIndex].toUpperCase();
            game.scrambledWord = shuffleWord(game.currentWord);
            
            while (game.scrambledWord === game.currentWord && game.currentWord.length > 1) {
                game.scrambledWord = shuffleWord(game.currentWord);
            }

            document.getElementById('scrambledWordDisplay').textContent = game.scrambledWord;
            document.getElementById('scrambleInput').value = '';
        }

        function submitScrambleGuess() {
            const game = wordScramble;
            if (!game.isRunning) return;
            
            const inputField = document.getElementById('scrambleInput');
            const guess = inputField.value.trim().toUpperCase();

            if (guess === game.currentWord) {
                game.score += game.currentWord.length * 5;
                scoreDisplay.textContent = game.score;
                alertCustom("Correct! Next word...");
                game.currentWordIndex++;
                loadNextWord();
            } else {
                alertCustom("Incorrect guess. Keep trying!");
                inputField.value = ''; 
            }
        }

        function gameOverWordScramble() {
            const game = wordScramble;
            game.isRunning = false;
            clearInterval(game.timerIntervalId);
            document.removeEventListener('keydown', handleKeyPressGlobal);
            gameControls.innerHTML = `
                <div class="bg-gray-700 p-8 rounded-xl w-full text-center shadow-2xl">
                    <h3 class="text-3xl font-bold text-cyan-400 mb-4">Time's Up!</h3>
                    <p class="text-xl text-white mb-6">You got ${game.currentWordIndex} words correct.</p>
                    <p class="text-4xl font-extrabold text-yellow-400 mb-6">Final Score: ${game.score}</p>
                    <button onclick="showGame('wordScramble')" class="cta-button bg-blue-600 text-white py-3 px-8 rounded-lg font-semibold hover:bg-blue-700">
                        Play Again
                    </button>
                </div>
            `;
            alertCustom(`Time's Up! Your final score in Word Scramble is ${game.score}.`);
        }
        
    </script>
</body>
</html>
